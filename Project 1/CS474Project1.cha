<?xml version="1.0"?><st-source><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><component-created><name>CS474</name> <type>package</type></component-created><class><name>NewDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>DictionaryInUse dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="dictionaryInUse">dictionaryInUse	^DictionaryInUse</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="dictionaryInUse:">dictionaryInUse: anObject	DictionaryInUse := anObject</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="dictionary">dictionary	^dictionary</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="dictionary:">dictionary: anObject	dictionary := anObject</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := nil.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>removing</category><body package="CS474" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := 0.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	^self subclassResponsibility</body></methods><methods><class-id>NewDictionary</class-id> <category>removing</category><body package="CS474" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self shouldNotImplement</body></methods><class><name>SortedDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="size1">size1	^size</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="size:">size: anObject	size := anObject</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="items">items	^items</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="items:">items: anObject	items := anObject</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := nil.	items := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| index element  |	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	items sortBlock:[:a :b | a &gt; b].	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedCollection new.a add: 1.a add: 10.a add: 5.a add: 2.a</do-it><class><name>DictionaryClass</name><environment>Smalltalk</environment><super>SortedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key">key	^key</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := nil.	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>DictionaryClass</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>DictionaryClass</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>DictionaryClass removeFromSystem</do-it><class><name>DictionaryPair</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="key">key	^key</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>DictionaryPair</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>DictionaryPair</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := nil.	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>DictionaryPair class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>DictionaryPair</class-id> <category>initialize-release</category><body package="CS474" selector="initialize:value:">initialize: new_key value:new_value	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := new_key.	value := new_value.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>DictionaryPair</class-id> <category>initialize-release</category><body package="CS474" selector="key:value:">key: new_key value:new_value	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := new_key.	value := new_value.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><remove-selector><class-id>DictionaryPair</class-id> <selector>initialize:value:</selector></remove-selector><do-it>| a |a:= (DictionaryPair new) key:5 value:10.a</do-it><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection sortBlock:[:a :b | a key &lt; b key].	 	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: _value.			self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.			self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair ) key: _key value:_value.		items add: pair.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		^self</body></methods><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size = size + 1.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start end current|		start := 1. 	end:= size.	current:= 0.					^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start end current dummy|		start := 1. 	end:= size.	current:= 0.		[start &lt; end] whileTrue: [		dummy := start + (end-1)/2.						].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		[(items at: current) key = position] ifTrue: [			] 				].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end = current - 1].												].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size := size + 1.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].												].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].												].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a at: 'crap'.</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a at: 'abc'.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size := size + 1.		^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:value:">add: _key value: _value	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><remove-selector><class-id>NewDictionary</class-id> <selector>add:value:</selector></remove-selector><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self at: newObject key put: newObject value</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self at: (newObject key) put: (newObject value)</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.</do-it><methods><class-id>NewDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self subclassResponsibility</body></methods><do-it>SortedDictionary organization addCategory: #enumerating</do-it><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self basicAt: index)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.				^self		</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size by: 1		do: [ :index | set add: (index value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index value) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) key) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) values) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a values</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		(items firstIndex) to: (items lastIndex)		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a values</do-it><do-it>NewDictionary organization addCategory: #allPairs</do-it><do-it>NewDictionary organization removeCategory: #allPairs</do-it><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: self size		do: [ :index | set add: (((self items) at: index))].			^set</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: self size		do: [ :index | set add: (index)].			^set</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		self do: [ :index | set add: (index)].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self basicAt: (items at: index))]</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: index ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: index key ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		self do: [ :index | set add: (index key) ].		^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self items at: index)]</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		self do: [ :index | set add: (index value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a values</do-it><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a allPairs</do-it><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		(items firstIndex) to: (items lastIndex) do:		[:index | aBlock value: (self items at: index)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		(items firstIndex) to: (items lastIndex) do:		[:i | aBlock value: (self items at: i)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		(1) to: (size) do:		[:i | aBlock value: (self items at: i)]</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><class><name>TreeDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>front size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front">front	^front</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front:">front: anObject	front := anObject</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="size1">size1	^size</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="size:">size: anObject	size := anObject</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	front := nil.	size := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BSTNode</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>BSTNode</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>BSTNode removeFromSystem</do-it><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>BSTNode removeFromSystem</do-it><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pair next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="pair">pair	^pair</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="pair:">pair: anObject	pair := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="next">next	^next</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="next:">next: anObject	next := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	pair := nil.	next := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>BSTNode removeFromSystem</do-it><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>right left pair </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	^right</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: anObject	right := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	^left</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: anObject	left := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="pair">pair	^pair</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="pair:">pair: anObject	pair := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	right := nil.	left := nil.	pair := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>BSTNode class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		pair:= (DictionaryPair new) key: _key value:_value.			size := size + 1.		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		"pair:= (DictionaryPair new) key: _key value:_value."			size := size + 1.		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		pair:= (DictionaryPair new) key: _key value:_value.			size := size + 1.		^pair</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	front := BSTNode new.	size := 0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil pair: dictpair.		size := size + 1.		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil pair: dictpair.		size := size + 1.		^Node</body></methods><class><name>BST</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root">root	^root</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="size1">size1	^size</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="size:">size: anObject	size := anObject</body></methods><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	root := nil.	size := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>BST class</class-id> <category>instance creation</category><body package="CS474" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>BST</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	root := nil.	size := 0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	front := BST new.	size := 0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>DictionaryPair organization addCategory: #adding</do-it><methods><class-id>DictionaryPair</class-id> <category>adding</category><body package="CS474" selector="add:">add: anObject^self</body></methods><remove-selector><class-id>DictionaryPair</class-id> <selector>add:</selector></remove-selector><do-it>DictionaryPair organization removeCategory: #adding</do-it><do-it>BST organization addCategory: #adding</do-it><methods><class-id>BST</class-id> <category>adding</category><body package="CS474" selector="add:">add: anObject^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil.	Node pair: dictpair.				size := size + 1.		^Node</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil.	Node pair: dictpair.		front add: Node.		size := size + 1.		^Node</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil.	Node pair: dictpair.		front add: Node.		size := size + 1.		^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new) left: nil right: nil.	Node pair: dictpair.		front at: _key put: Node.		size := size + 1.		^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: objectroot = nil ifTrue: [root:= (BSTNode new)].^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: objectroot = nil ifTrue: [root:= object].^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: objectroot = nil ifTrue: [root:= object. ^root].^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) &lt; key) ifTrue: [head:= head left]. 		((head pair key) &gt; key) ifTrue: [head:= head right]. 		((head pair key) = key) ifTrue: [^self]. 									].((head pair key) &lt; key) ifTrue: [parent := parent left.							parent:= object]					ifFalse: [parent := parent right.							parent:= object].^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new).	Node pair: dictpair.		front at: _key put: Node.		size := size + 1.		^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((head pair key) &lt; key) ifTrue: [parent := parent left.							parent:= object]					ifFalse: [parent := parent right.							parent:= object].^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent := parent left.							parent:= object]					ifFalse: [parent := parent right.							parent:= object].^self</body></methods><do-it>| a |a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.^self</body></methods><do-it>a.</do-it><do-it>a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent := parent left.							parent:= object]					ifFalse: [parent := parent right.							parent:= object].^self</body></methods><do-it>a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent left: object]					ifFalse: [parent right: object].^self</body></methods><do-it>a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent left: object]					ifFalse: [parent right: object].size = size + 1.^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent left: object]					ifFalse: [parent right: object].size := size + 1.^self</body></methods><do-it>a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>front</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>front</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>TreeDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front:">front: anObject	root := anObject</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	root := BST new.	size := 0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front">front	^root</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new).	Node pair: dictpair.		root at: _key put: Node.		size := size + 1.		^self</body></methods><do-it>a:= TreeDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 13, 2018' '11:00:25 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 11:00:25 PM on February 13, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 13, 2018' '11:00:48 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 11:00:48 PM on February 13, 2018."</do-it><methods><class-id>BST</class-id> <category>adding</category><body package="CS474" selector="add:">add: object|  head  parent key|key:= object pair key.root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head left] 						ifFalse: [head:= head right]. 											].((parent pair key) &lt; key) ifTrue: [parent left: object]					ifFalse: [parent right: object].size := size + 1.^self</body></methods><do-it>| dictpair node BSTree | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.node:= BSTNode new.node pair:dictpair.BSTree := BST new. BSTree add: node.BSTree.</do-it><do-it>| dictpair node BSTree | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.node:= BSTNode new.node pair:dictpair.BSTree := BST new. BSTree add: node.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree add: node.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree add: node.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree add: node.BSTree add: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree add: node.BSTree add: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree add: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree at: (node pair key) put: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict. </do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].((parent pair key) &lt; key) ifTrue: [parent right: object]					ifFalse: [parent left: object].size := size + 1.^self</body></methods><methods><class-id>BST</class-id> <category>adding</category><body package="CS474" selector="add:">add: object|  head  parent key|key:= object pair key.root = nil ifTrue: [root:= object. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].((parent pair key) &lt; key) ifTrue: [parent right: object]					ifFalse: [parent left: object].size := size + 1.^self</body></methods><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict. </do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>left</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>left</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>right _leftNode pair </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left">left	^_leftNode</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	right := nil.	_leftNode := nil.	pair := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="left:">left: anObject	_leftNode := anObject</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>right</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>right</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>BSTNode</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>_rightNode _leftNode pair </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right:">right: anObject	_rightNode := anObject</body></methods><methods><class-id>BSTNode</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	_rightNode := nil.	_leftNode := nil.	pair := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>BSTNode</class-id> <category>accessing</category><body package="CS474" selector="right">right	^_rightNode</body></methods><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict. </do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getSize">getSize	^size</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getSize">getSize	^size</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getSize">getSize	^size</body></methods><remove-selector><class-id>SortedDictionary</class-id> <selector>size1</selector></remove-selector><remove-selector><class-id>TreeDictionary</class-id> <selector>size1</selector></remove-selector><remove-selector><class-id>BST</class-id> <selector>size1</selector></remove-selector><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="search:">search: key|  head  parent |root = nil ifTrue: [^nil].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^head]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].^nil</body></methods><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict. </do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= root search: key.		^searchObject.</body></methods><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict. </do-it><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><methods><class-id>Refactory.Browser.RBParseTreeRule class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="getNode:">getNode: aString 	^(self new)		searchString: aString;		yourself</body></methods><methods><class-id>UI.DocumentAutocomplete</class-id> <category>private - search</category><body package="UIBasics-Text2" selector="getNode:">getNode: word	searchSemaphore critical: [		searchProcess == nil ifFalse: [searchProcess terminate].		searchProcess := [self backgroundSearch: word] newProcess.		searchProcess name: 'Autocomplete search for: ', word.		searchProcess priority: Processor userBackgroundPriority.		searchProcess resume]</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getNode:">getNode: key|  head  parent |root = nil ifTrue: [^nil].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^head]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].^nil</body></methods><methods><class-id>UI.DocumentView</class-id> <category>accessing - settings</category><body package="UIBasics-Text2" selector="getNode:">getNode: aDocumentSearch	"Set the search object for the receiver."	search := aDocumentSearch initialize: self</body></methods><methods><class-id>UI.DocumentAutocomplete</class-id> <category>actions - events</category><body package="UIBasics-Text2" selector="startSearch">startSearch	| word |	word := self currentSearchWord.	word isEmpty ifTrue: [^self hideWindow].	(self isSuggestableWord: word) ifFalse: [^self hideWindow].	self isInCommentOrNonSymbolLiteral ifTrue: [^self hideWindow].	self getNode: word.</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private</category><body package="Tools-Changes" selector="selectMatching:fromRemoved:">selectMatching: promptPrefix fromRemoved: aBoolean	"Return an association of string to list where the list contains	 all unremoved changes which match a string."	| string |	string := Dialog				request: ((#{RxParser} isDefined					ifTrue: [#x1sChangesContainingRegexp &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; changes containing regexp']					ifFalse: [#x1sChangesContainingString &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; changes containing string'])						expandMacrosWith: promptPrefix).	string isEmpty ifTrue: [^string -&gt; List new].	Cursor execute showWhile:		[| re |		^string -&gt; (#{RxParser} isDefined						ifTrue:							[re := string asRegex.							list select:								[ :change |								change text ~~ nil									and: [ (aBoolean = (removed includes: change)									and: [re getNode: change text])]]]						ifFalse:							[string first = $* ifFalse: [string := '*', string].							string last = $* ifFalse: [string := string, '*'].							list select:								[ :change |								change text ~~ nil									and: [ (aBoolean = (removed includes: change)									and: [string match: change text])]]])]</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= root getNode: key.		^searchObject.</body></methods><remove-selector><class-id>Refactory.Browser.RBParseTreeRule class</class-id> <selector>search:</selector></remove-selector><remove-selector><class-id>UI.DocumentAutocomplete</class-id> <selector>search:</selector></remove-selector><remove-selector><class-id>BST</class-id> <selector>search:</selector></remove-selector><remove-selector><class-id>UI.DocumentView</class-id> <selector>search:</selector></remove-selector><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getNode:">getNode: key|  head  |root = nil ifTrue: [^nil].head:= root.[(head) ~= nil] whileTrue: [		((head pair key) = key) ifTrue: [^head]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].^nil</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getValueAt:">getValueAt: key|  head  |root = nil ifTrue: [^nil].head:= root.[(head) ~= nil] whileTrue: [		((head pair key) = key) ifTrue: [^(head pair value)]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].^nil</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getValueAt:">getValueAt: key	|  searchObject |		searchObject:= root getNode: key.		(searchObject ~= nil) ifTrue: [^(searchObject pair value)] ifFalse: [^nil].</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= root getValueAt: key.		^searchObject.</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="getValueAt:">getValueAt: key	|  searchObject |		searchObject:= self getNode: key.		(searchObject ~= nil) ifTrue: [^(searchObject pair value)] ifFalse: [^nil].</body></methods><do-it>| dict| dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: object|  head  parent |root = nil ifTrue: [root:= object. size := size + 1. ^root].head:= root.parent:= nil.[(head) ~= nil] whileTrue: [		parent:= head.		((head pair key) = key) ifTrue: [^self]. 		((head pair key) &lt; key) ifTrue: [head:= head right] 						ifFalse: [head:= head left]. 											].((parent pair key) &lt; key) ifTrue: [parent right: object]					ifFalse: [parent left: object].size := size + 1.^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left)."visit the node"self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).1 to: size do:	[:i | aBlock value: (aNode pair)].self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(root iterate: [aBlock] on:root root)	</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(root iterate: [aBlock] on: (root root))</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>root</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>root</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>TreeDictionary</name><environment>Smalltalk</environment><super>NewDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		dictpair:= (DictionaryPair new) key: _key value:_value.	Node:= (BSTNode new).	Node pair: dictpair.		tree at: _key put: Node.		size := size + 1.		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front:">front: anObject	tree := anObject</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="front">front	^tree</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	tree := BST new.	size := 0.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(tree iterate: [aBlock] on: (tree root))</body></methods><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict at: 'abc'. </do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict.</do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| set |		set:= OrderedCollection new.		self do: [ :index | set add: (index key) ].		^set</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).1 to: 1 do:	[:i | aBlock value: (aNode pair)].self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value: (aNode pair).self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).[aBlock value: (aNode pair)].self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value: (aNode pair).self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:">iterate: aBlock| aNode |aNode:= root.(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value: (aNode pair).self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(tree iterate: [aBlock])</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| set |		set:= OrderedCollection new.		self do: [ :pair | set add: (pair key) ].		^set</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(tree iterate: [aBlock] on: (tree root))</body></methods><remove-selector><class-id>BST</class-id> <selector>iterate:</selector></remove-selector><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| set someblock|		set:= OrderedCollection new.		someblock:= [set add: 'hi' ].		self do: someblock.		^set</body></methods><methods><class-id>TreeDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^(tree iterate: aBlock on: (tree root))</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value.self iterate:aBlock on: (aNode right).^self</body></methods><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict keys.</do-it><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value: (aNode pair)self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>BST</class-id> <category>accessing</category><body package="CS474" selector="iterate:on:">iterate: aBlock on: aNode(aNode = nil) ifTrue: [^aNode].self iterate:aBlock on: (aNode left).aBlock value: (aNode pair).self iterate:aBlock on: (aNode right).^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| set someblock|		set:= OrderedCollection new.		someblock:= [:pair | set add: pair ].		self do: someblock.		^set</body></methods><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict keys.</do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| set someblock|		set:= OrderedCollection new.		someblock:= [:pair | set add: pair key ].		self do: someblock.		^set</body></methods><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict keys.</do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set someblock|		set:= OrderedCollection new.		someblock:= [:pair | set add: pair value ].		self do: someblock.		^set</body></methods><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict keys.</do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict values.</do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict allPairs.</do-it><do-it>dict at: 'abc' put: '2'.</do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict allPairs.</do-it><do-it>dict := TreeDictionary new.dict at: 'crap' put: '1'.dict at: 'abc' put: '2'.dict at: 'do' put: '3'.dict keys.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 14, 2018' '4:11:26 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 4:11:26 PM on February 14, 2018."</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>|a|a := SortedDictionary new. a at: 'abc' put: '1'.a at: 'shit' put: '2'.a at: 'abc'.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>a := SortedDictionary new. a at: 'abc' put: '1'.a at: 'shit' put: '2'.a at: 'abc'.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>a := SortedDictionary new. a at: 'abc' put: '1'.a at: 'shit' put: '2'.a at: 'abc'. </do-it><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		items do:		[:i | aBlock value: (self items at: i)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:i | aBlock value: (self items at: i)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^((items at: current) )]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>a := SortedDictionary new. a at: 'abc' put: '1'.a at: 'shit' put: '2'.a getPair: 'abc'</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) 	ifTrue: [		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		size := size + 1.	] ifFalse: [		(self getPair: _key) value: _value.	].				^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) 	ifTrue: [		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		size := size + 1.	] ifFalse: [		(self getPair: _key) value: _value.	].				^(self getPair: _key)</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items getPair: current) key = position) ifTrue: [^((items at: current) )]. 		((items getPair: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^((items at: current) )]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) 	ifTrue: [		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		size := size + 1.	] ifFalse: [		pair := (DictionaryPair new).		pair := self getPair: _key.		pair value: _value.	].				^(self getPair: _key)</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) 	ifTrue: [		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		size := size + 1.	] ifFalse: [		pair := (DictionaryPair new).		pair := self getPair: _key.		pair value: _value.	].				^pair</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2 floor) .		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2 floor)) .		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := ((end -1)/2 floor).		current := current + 1.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := ((end -1)/2 floor).		current := (current + 1) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>a := SortedDictionary new. a at: 'abc' put: '1'.a at: 'shit' put: '2'.a at: 'abc'.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree at: (node pair key) put: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree at: (node pair key) put: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>|a|a := SortedDictionary new.a.</do-it><do-it>|a|a := SortedDictionary new.a at: 'abc' put: '1'.a.</do-it><do-it>|a|a := SortedDictionary new.a at: 'abc' put: '1'.a.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) ifTrue: [		pair:= (DictionaryPair new) key: _key value:_value.			items add: pair.		size := size + 1.				] ifFalse: [		pair:= self getPair: _key.		pair value: _value.				].				^pair</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "				|  start current end|	(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "				|  start current end|	(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^(items at: current value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>|a|a := SortedDictionary new.a at: 'abc' put: '1'.a at: 'def' put: '2'.a at: 'abc'.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "				|  start current end|	(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>a := SortedDictionary new.a at: 'abc' put: '1'.a at: 'def' put: '2'.a at: 'abc'.</do-it><do-it>a := SortedDictionary new.a at: 'abc' put: '1'.a at: 'def' put: '2'.a getPair: 'abc'.</do-it><do-it>a := SortedDictionary new.a at: 'abc' put: '1'.a at: 'def' put: '2'.a at: 'abc' put: '5'.a at: 'abc'.</do-it><do-it>a := SortedDictionary new.a at: 'abc' put: '1'.a at: 'def' put: '2'.a at: 'cbc' put: '5'.a at: 'abc'.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 15, 2018' '11:12:46 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 11:12:46 PM on February 15, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 15, 2018' '11:12:58 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 11:12:58 PM on February 15, 2018."</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [self at: (newObject key) put: (newObject value). ^nil].	</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getNode:">getNode: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><remove-selector><class-id>TreeDictionary</class-id> <selector>getNode:</selector></remove-selector><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  node |		node:= tree getNode: key.		^(node pair)</body></methods><class><name>NewDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>DictionaryInUse dictionary key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>NewDictionary addInstVarName: 'key'</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	| oldPair |	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [oldPair := self getPair: key.				self at: (newObject key) put: (newObject value).].</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	| oldPair |	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [				self at: (newObject key) put: (newObject value).].</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [				self at: (newObject key) put: (newObject value).].</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection sortBlock:[:a :b | a key &lt; b key].	dictionary = self.	 	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection sortBlock:[:a :b | a key &lt; b key].	dictionary := self.	 	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	tree := BST new.	size := 0.	dictionary := self.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection sortBlock:[:a :b | a key &lt; b key].	dictionary := self.	DictionaryInUse := 1.		" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	tree := BST new.	size := 0.	dictionary := self.	DictionaryInUse := 2.		" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := 0.	dictionary := nil.		" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [ oldPair := dictionary getPair: key.				self at: (newObject key) put: (newObject value).].</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |	(self at: (newObject key)) 		ifNil: [self at: (newObject key) put: (newObject value). ^nil] 		ifNotNil: [ oldPair := dictionary getPair: key.				self at: (newObject key) put: (newObject value). 				^oldPair].</body></methods><do-it>| tree pair |tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.pair.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: key).		(oldPair) 	ifNil: [self at: (newObject key) put: (newObject value). ^nil] 				ifNotNil: [ self at: (newObject key) put: (newObject value). ^oldPair].</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: key).self at: (newObject key) put: (newObject value).		(oldPair) 	ifNil: [ ^nil] 				ifNotNil: [ ^oldPair].</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abd' value: '5'.pair:= tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: key).self at: (newObject key) put: (newObject value).^oldPair.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: key).self at: (newObject key) put: (newObject value).^self at: key.</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** ""| oldPair |(oldPair := dictionary getPair: key)."self at: (newObject key) put: (newObject value).^self at: key.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: key).self at: (newObject key) put: (newObject value).^oldPair.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.pair := tree at: 'abc' put: '5'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree getPair: 'abc'.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree getPair: 'abc'.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: (newObject key)).self at: (newObject key) put: (newObject value).^oldPair.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><class><name>NewDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>DictionaryInUse dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) ifTrue: [			dictpair:= (DictionaryPair new) key: _key value:_value.		Node:= (BSTNode new).		Node pair: dictpair.			tree at: _key put: Node.			size := size + 1.]	ifFalse: [].		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil) ifTrue: [			dictpair:= (DictionaryPair new) key: _key value:_value.		Node:= (BSTNode new).		Node pair: dictpair.			tree at: _key put: Node.			size := size + 1.]	ifFalse: [	dictpair:= self getPair: _key.			dictpair value: _value.].		^self</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil)	 ifTrue: [		dictpair:= (DictionaryPair new) key: _key value:_value.		Node:= (BSTNode new).		Node pair: dictpair.		tree at: _key put: Node.		size := size + 1.]		ifFalse: [	dictpair:= self getPair: _key.			dictpair value: _value.].		^self</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair:= tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair:= tree add: dictpair.pair.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair.BSTree := BST new. BSTree at: (node pair key) put: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2 | dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.BSTree at: (node2 pair key) put: node2.BSTree.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| dictpair Node |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		((self at: _key) = nil)	 ifTrue: [		dictpair:= (DictionaryPair new) key: _key value:_value.		Node:= (BSTNode new).		Node pair: dictpair.		tree at: _key put: Node.		size := size + 1.]		ifFalse: [	dictpair:= self getPair: _key.			dictpair value: _value.].		^dictpair</body></methods><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := BST new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := TreeDictionary new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| dictpair node BSTree dictpair2  node2  return| dictpair := DictionaryPair new.dictpair key: 'crap' value: '1'.dictpair2 := DictionaryPair new.dictpair2 key: 'abc' value: '2'.node:= BSTNode new.node pair:dictpair.node2:= BSTNode new.node2 pair:dictpair2.BSTree := TreeDictionary new. BSTree at: (node pair key) put: node.return := BSTree at: (node2 pair key) put: node2.return.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair:= tree add: dictpair.pair.</do-it><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  node |		node:= tree getNode: key.		(node) ifNil: [^nil] ifNotNil: [^(node pair)]		</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="getPair:">getPair: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  node |		node:= tree getNode: key.		(node) ifNil: [^nil] ifNotNil: [^(node pair)].</body></methods><do-it>| tree pair dictpair|tree := TreeDictionary new.pair := tree at: 'abcd' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.pair := tree at: 'abcd' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.pair := tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair := tree add: dictpair.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: (newObject key))."self at: (newObject key) put: (newObject value)."^oldPair.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair := tree add: dictpair.pair.</do-it><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair |(oldPair := dictionary getPair: (newObject key)).self at: (newObject key) put: (newObject value).^oldPair.</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair currentPair|(currentPair := dictionary getPair: (newObject key)).oldPair ifNotNil: [currentPair := (DictionaryPair new) key: (oldPair key) value: (oldPair value)].self at: (newObject key) put: (newObject value).^oldPair.</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "| oldPair currentPair|(currentPair := dictionary getPair: (newObject key)).currentPair ifNotNil: [oldPair := (DictionaryPair new) key: (currentPair key) value: (currentPair value)].self at: (newObject key) put: (newObject value).^oldPair.</body></methods><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '5'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := SortedDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.tree at: 'abc' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.tree at: 'abcssdasd' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.pair := tree add: dictpair.pair.</do-it><do-it>| tree pair dictpair|tree := TreeDictionary new.pair:=tree at: 'abcssdasd' put: '1'.dictpair := DictionaryPair new.dictpair key: 'abc' value: '10'.tree add: dictpair.pair.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:21 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:21 PM on February 17, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:29 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:29 PM on February 17, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:59 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:59 PM on February 17, 2018."</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 634 187 1252 711 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="applyBlock">applyBlock	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].		dictionary := SortedDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"		dictionary ifNotNil: [self resetDictionary].		dictionary := TreeDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	dictionary ifNotNil: [dictionary := nil].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		^self</body></methods><component-created><name>BinaryTree</name> <type>package</type></component-created><name-space><name>MyTree</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></name-space><comment><name-space-id>MyTree</name-space-id><body>name:         Wenling Chenproject:        CS 474 project 1CS account: wchenfile name:     chen.stDate:           10/7/2007Wchen is the namespace for this project</body></comment><class><name>Node</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><comment><class-id>MyTree.Node</class-id><body>Node class represent nodes in an binary search tree</body></comment><class><name>BTreeEditor</name><environment>MyTree</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output input myTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><comment><class-id>MyTree.BTreeEditor</class-id><body>This the user interface for the project.Instance Variables:	input	&lt;ValueModel&gt;	accept a list of numbers for adding to the tree or deleting from the tree	myTree	&lt;BTree&gt;	a binary search tree	output	&lt;ValueModel&gt;	show the result of each operations: 		add node, delete node, add all nodes' total, print in-order, print pre-order, and print post-order</body></comment><class><name>BTree</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root addStatus removeStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><comment><class-id>MyTree.BTree</class-id><body>The BTree represent a binary search tree for the projectInstance Variables:	root	&lt;Object&gt;	the root node of the tree	addStatus 		the status of add node operation	removeStatus    the status of delete node operation</body></comment><methods><class-id>MyTree.BTree class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>MyTree.BTree class</class-id> <category>testing</category><body package="BinaryTree" selector="addNode">addNode	| t |	t := BTree new.	t add: 30.	t add: 50.	t add: 70.	t add: 90.	t add: 20.	t add: 60.	Transcript show: t printTreeInOrder.	Transcript show: t printTreePreOrder.	Transcript show: t printTreePostOrder.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root">root	^root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="insert:">insert: x	root := self insert: x at: root </body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus:">removeStatus: aString	removeStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus:">addStatus: aString	addStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	^self addAllNodes: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMax">finMax	^self valueAt: (self findMax: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus">removeStatus	^removeStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMin">finMin	^self findMin: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	"remove a node"	root := self remove: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="makeEmpty">makeEmpty	root := nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	^self printTreePreOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	^self printTreeInOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus">addStatus	^addStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	^self printTreePostOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="isEmpty">isEmpty	^root isNil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	root := self add: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="find:">find: x 	^self valueAt: (self find: x at: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMin:">findMin: aNode	aNode isNil ifTrue: [^nil].	aNode left isNil ifTrue: [ ^aNode ].	^ self findMin: aNode left.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMax:">findMax: t 	| tmp |	tmp := t.	tmp isNil ifTrue: [^nil].	[tmp right isNil] whileFalse: [tmp := tmp right].	^tmp</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="addAllNodes:">addAllNodes: aNode 	| left middle right |	aNode isNil ifTrue: [ ^0 ].	left := self addAllNodes: aNode left.	middle := aNode value.	right := self addAllNodes: aNode right.	^(left + middle + right)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="add:at:">add: aNumber at: aNode 	"add a number at the tree node"	aNode isNil ifTrue: [			|newNode|			newNode := Node new: aNumber.			addStatus isNil 				ifTrue: [ addStatus := newNode value printString ]				ifFalse: [ addStatus := addStatus, ' ', newNode value printString ].			^newNode ]		ifFalse: [			aNode value &gt; aNumber 				ifTrue: 					["add smaller number to the left tree"					aNode left: (self add: aNumber at: aNode left ).					^aNode ].			aNode value &lt; aNumber 				ifTrue: 					["add bigger number to the right tree"					aNode right: (self add: aNumber at: aNode right ) .					^aNode ].			^aNode ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreeInOrder:">printTreeInOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreeInOrder: aNode left.			middle := aNode value printString.			right := self printTreeInOrder: aNode right.			space := String with: Character space.			^left, space, middle, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="find:at:">find: x at: t 	| tmp |	tmp := t.	[tmp isNil not] whileTrue: 			[tmp &gt; x ifTrue: [tmp := tmp left].			tmp &lt; x ifTrue: [tmp := tmp right].			tmp = x ifTrue: [^tmp]].	^nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePostOrder:">printTreePostOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePostOrder: aNode left.			middle := aNode value printString.			right := self printTreePostOrder: aNode right.			space := String with: Character space.			^left, space, right, space, middle  ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="valueAt:">valueAt: t 	t isNil ifTrue: [^nil] ifFalse: [^t value]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="insert:at:">insert: x at: t |tmp|	"insert number x at node t"	t isNil ifTrue: [ tmp := Node new: x].	"insert smaller number to the left"	t &gt; x ifTrue: [t left: (self insert: x at: t left)].	"insert bigger number to the right"	t &lt; x ifTrue: [t right: (self insert: x at: t right)]	"if t equals x, do nothing"	</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePreOrder:">printTreePreOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePreOrder: aNode left.			middle := aNode value printString.			right := self printTreePreOrder: aNode right.			space := String with: Character space.			^middle, space, left, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="remove:at:">remove: aNumber at: aNode 	"remove a number at the tree node"	"if tree is empty, nothing to remove"	aNode isNil ifTrue: [^nil].	"remove smaller number from the left tree"	aNode value &gt; aNumber ifTrue: [		aNode left: (self remove: aNumber at: aNode left ).		^aNode ].	"remove bigger number from the right tree"	aNode value &lt; aNumber ifTrue: [		aNode right: (self remove: aNumber at: aNode right ).		^aNode ].	"the current node contains the number; 	four cases: 0 child, 1 left child, 1 right child, 2 children"	"we are sure we will delete a node, therefor, update the remove status"	self removeStatus isNil		ifTrue: [ self removeStatus: aNumber printString ]		ifFalse: [ self removeStatus: removeStatus, '  ', aNumber printString ].	"when the current node have 2 children"	( aNode left isNil not ) &amp; ( aNode right isNil not ) ifTrue: [		aNode value: ( self findMin: aNode right ) value.		aNode right: ( self remove: aNode value at: aNode right ).		^aNode ].	"when the current node has left child but not right child"	aNode left isNil ifFalse: [ ^aNode left ].	"when the current node has right child but not left child"	aNode right isNil ifFalse: [ ^aNode right ].	"when the current node is a leaf node"	^nil.</body></methods><methods><class-id>MyTree.Node class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new:">new: aNumber	"Answer a newly created and initialized instance."	^super new initialize: aNumber</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&lt;">&lt; x 	^value &lt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="=">= x 	^value = x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&gt;">&gt; x 	^value &gt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize:">initialize: aNumber	"Initialize a newly created instance. This method must answer the receiver."	value := aNumber.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value:">value: x	value := x</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height:">height: x^height := x.</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left:">left: t	left := t</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right">right	^right</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value">value	^value</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	value &gt; aNumber 		ifTrue: 			[left isNil 				ifTrue: [^left := Node new: aNumber]				ifFalse: [^left add: aNumber]].	value &lt; aNumber 		ifTrue: 			[right isNil 				ifTrue: [^right := Node new: aNumber]				ifFalse: [^right add: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height">height	^height</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	value &gt; aNumber 		ifTrue: [left isNil ifTrue: [^nil] ifFalse: [^left remove: aNumber]].	value &lt; aNumber 		ifTrue: [right isNil ifTrue: [^nil] ifFalse: [^right remove: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left">left	^left</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right:">right: t	right := t</body></methods><methods><class-id>MyTree.BTreeEditor class</class-id> <category>interface specs</category><body package="BinaryTree" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Binary Search Tree Editor' 			#bounds: #(#{Graphics.Rectangle} 1684 303 2255 518 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 21 19 ) 					#name: #inputLabel 					#label: 'Input' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 100 ) 					#name: #outputLabel 					#label: 'Output' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 59 20 545 45 ) 					#name: #InputField 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 61 100 547 125 ) 					#name: #outputField 					#model: #output 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 61 57 179 88 ) 					#name: #addNodeButton 					#model: #addNode 					#label: 'Add Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 58 302 89 ) 					#name: #deleteButton 					#model: #deleteNode 					#label: 'Delete Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 59 139 177 170 ) 					#name: #addAllButton 					#model: #addAllNodes 					#label: 'Add All Nodes' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 182 139 300 170 ) 					#name: #printTreeInOrderButton 					#model: #printTreeInOrder 					#label: 'Print tree in-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 306 139 424 170 ) 					#name: #printTreePreOderButton 					#model: #printTreePreOrder 					#label: 'Print tree pre-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 429 139 547 170 ) 					#name: #printTreePostOrderButton 					#model: #printTreePostOrder 					#label: 'Print tree post-order' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="output">output	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^output isNil		ifTrue:			[output := String new asValue]		ifFalse:			[output]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="input">input	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^input isNil		ifTrue:			[input := String new asValue]		ifFalse:			[input]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	myTree := BTree new</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	"This stub method was generated by UIDefiner"	output value: 'Tree pre-order: ', myTree printTreePreOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	"This stub method was generated by UIDefiner"	output value: 'Tree post-order: ', myTree printTreePostOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	"This stub method was generated by UIDefiner"	output value: 'Tree in-order: ', myTree printTreeInOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="deleteNode">deleteNode	"delete one or more numbers from the tree"	| inputStream token |	myTree removeStatus: nil.	inputStream := input value readStream.	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree remove: token asNumber.	].	input value: ''.	myTree removeStatus isNil		ifTrue: [ output value: 'deleted nodes: (none)' ]		ifFalse: [ output value: 'deleted nodes: ', myTree removeStatus ].</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	"Add the values of all tree nodes"	output value: 'All Nodes totally: ' , myTree addAllNodes printString</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addNode">addNode	"add one or more numbers to a tree"	| inputStream token |	"clean up the tree's add node status"	myTree addStatus: nil.	"get the inputField and set it as a readonly stream"	inputStream := input value readStream.	"while reading stream is not finished, get a token as a number;	and add it to the binary search tree"	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree add: token asNumber.	].	"set inputField empty"	input value: ''.	"output status of the add node operation"	myTree addStatus isNil		ifTrue: [ output value: 'added nodes: (none)' ]		ifFalse: [ output value: 'added nodes: ', myTree addStatus ]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="applyBlockText">applyBlockText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^applyBlockText isNil		ifTrue:			[applyBlockText := String new asValue]		ifFalse:			[applyBlockText]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText  getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getValueFromKey">getValueFromKey	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getValueFromKey isNil		ifTrue:			[getValueFromKey := String new asValue]		ifFalse:			[getValueFromKey]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey  valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="valueInput">valueInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueInput isNil		ifTrue:			[valueInput := String new asValue]		ifFalse:			[valueInput]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput  keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="keyInput">keyInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyInput isNil		ifTrue:			[keyInput := String new asValue]		ifFalse:			[keyInput]</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token key value |		key := keyInput value readStream.			^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		^_value.</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		position == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		key == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 685 236 1309 684 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 341 0 78 0 576 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 343 0 110 0 575 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value token|		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].	_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.	"	[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	]."		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><do-it>| a |a := SortedDictionary new.a at: 'abc' put: '4'.a at: 'sad'.</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput  getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getAllKeys">getAllKeys	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getAllKeys isNil		ifTrue:			[getAllKeys := SelectionInList new]		ifFalse:			[getAllKeys]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllPairsList">AllPairsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllPairsList isNil		ifTrue:			[AllPairsList := SelectionInList new]		ifFalse:			[AllPairsList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList  AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllKeysList">AllKeysList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllKeysList isNil		ifTrue:			[AllKeysList := SelectionInList new]		ifFalse:			[AllKeysList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllValuesList">AllValuesList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllValuesList isNil		ifTrue:			[AllValuesList := SelectionInList new]		ifFalse:			[AllValuesList]</body></methods><remove-selector><class-id>DictionaryApp</class-id> <selector>getAllKeys</selector></remove-selector><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		^list</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.		keyInput value: ''.	valueInput value: ''.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		getValueFromKey value: ''.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList = list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList := list.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 571 247 1195 695 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 25 0 294 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 405 0 27 0 578 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 298 0 78 0 435 0 97 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 110 0 434 0 131 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 703 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 258 0 80 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 678 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 456 0 78 0 691 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 110 0 691 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 266 0 230 0 467 0 419 0 ) 					#name: #List1 					#model: #AllKeysList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 56 0 191 0 212 0 212 0 ) 					#name: #ActionButton6 					#model: #getAllPairs 					#label: 'All Pairs' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 528 0 192 0 676 0 214 0 ) 					#name: #ActionButton8 					#model: #getAllValues 					#label: 'All Values' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 503 0 229 0 697 0 417 0 ) 					#name: #List3 					#model: #AllValuesList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 229 0 225 0 416 0 ) 					#name: #List2 					#model: #AllPairsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 282 0 191 0 448 0 212 0 ) 					#name: #ActionButton7 					#model: #getAllKeys 					#label: 'All Keys' 					#defaultable: true ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: (list at: i)].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: i].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList list: list. </body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.				AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: finalList.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllValuesList list: list.</body></methods><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:59 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:59 PM on February 17, 2018."</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 634 187 1252 711 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="applyBlock">applyBlock	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].		dictionary := SortedDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"		dictionary ifNotNil: [self resetDictionary].		dictionary := TreeDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	dictionary ifNotNil: [dictionary := nil].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		^self</body></methods><component-created><name>BinaryTree</name> <type>package</type></component-created><do-it>CodeComponent	create: #package	named: 'BinaryTree'</do-it><name-space><name>MyTree</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></name-space><do-it>Smalltalk defineNameSpace: #MyTree	private: false	imports: '			private Smalltalk.*			'	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><name-space-id>MyTree</name-space-id><body>name:         Wenling Chenproject:        CS 474 project 1CS account: wchenfile name:     chen.stDate:           10/7/2007Wchen is the namespace for this project</body></comment><class><name>Node</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #Node	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'value left right height '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.Node</class-id><body>Node class represent nodes in an binary search tree</body></comment><class><name>BTreeEditor</name><environment>MyTree</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output input myTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTreeEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'output input myTree '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTreeEditor</class-id><body>This the user interface for the project.Instance Variables:	input	&lt;ValueModel&gt;	accept a list of numbers for adding to the tree or deleting from the tree	myTree	&lt;BTree&gt;	a binary search tree	output	&lt;ValueModel&gt;	show the result of each operations: 		add node, delete node, add all nodes' total, print in-order, print pre-order, and print post-order</body></comment><class><name>BTree</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root addStatus removeStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTree	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root addStatus removeStatus '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTree</class-id><body>The BTree represent a binary search tree for the projectInstance Variables:	root	&lt;Object&gt;	the root node of the tree	addStatus 		the status of add node operation	removeStatus    the status of delete node operation</body></comment><methods><class-id>MyTree.BTree class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>MyTree.BTree class</class-id> <category>testing</category><body package="BinaryTree" selector="addNode">addNode	| t |	t := BTree new.	t add: 30.	t add: 50.	t add: 70.	t add: 90.	t add: 20.	t add: 60.	Transcript show: t printTreeInOrder.	Transcript show: t printTreePreOrder.	Transcript show: t printTreePostOrder.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root">root	^root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="insert:">insert: x	root := self insert: x at: root </body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus:">removeStatus: aString	removeStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus:">addStatus: aString	addStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	^self addAllNodes: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMax">finMax	^self valueAt: (self findMax: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus">removeStatus	^removeStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMin">finMin	^self findMin: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	"remove a node"	root := self remove: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="makeEmpty">makeEmpty	root := nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	^self printTreePreOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	^self printTreeInOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus">addStatus	^addStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	^self printTreePostOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="isEmpty">isEmpty	^root isNil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	root := self add: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="find:">find: x 	^self valueAt: (self find: x at: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMin:">findMin: aNode	aNode isNil ifTrue: [^nil].	aNode left isNil ifTrue: [ ^aNode ].	^ self findMin: aNode left.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMax:">findMax: t 	| tmp |	tmp := t.	tmp isNil ifTrue: [^nil].	[tmp right isNil] whileFalse: [tmp := tmp right].	^tmp</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="addAllNodes:">addAllNodes: aNode 	| left middle right |	aNode isNil ifTrue: [ ^0 ].	left := self addAllNodes: aNode left.	middle := aNode value.	right := self addAllNodes: aNode right.	^(left + middle + right)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="add:at:">add: aNumber at: aNode 	"add a number at the tree node"	aNode isNil ifTrue: [			|newNode|			newNode := Node new: aNumber.			addStatus isNil 				ifTrue: [ addStatus := newNode value printString ]				ifFalse: [ addStatus := addStatus, ' ', newNode value printString ].			^newNode ]		ifFalse: [			aNode value &gt; aNumber 				ifTrue: 					["add smaller number to the left tree"					aNode left: (self add: aNumber at: aNode left ).					^aNode ].			aNode value &lt; aNumber 				ifTrue: 					["add bigger number to the right tree"					aNode right: (self add: aNumber at: aNode right ) .					^aNode ].			^aNode ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreeInOrder:">printTreeInOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreeInOrder: aNode left.			middle := aNode value printString.			right := self printTreeInOrder: aNode right.			space := String with: Character space.			^left, space, middle, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="find:at:">find: x at: t 	| tmp |	tmp := t.	[tmp isNil not] whileTrue: 			[tmp &gt; x ifTrue: [tmp := tmp left].			tmp &lt; x ifTrue: [tmp := tmp right].			tmp = x ifTrue: [^tmp]].	^nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePostOrder:">printTreePostOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePostOrder: aNode left.			middle := aNode value printString.			right := self printTreePostOrder: aNode right.			space := String with: Character space.			^left, space, right, space, middle  ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="valueAt:">valueAt: t 	t isNil ifTrue: [^nil] ifFalse: [^t value]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="insert:at:">insert: x at: t |tmp|	"insert number x at node t"	t isNil ifTrue: [ tmp := Node new: x].	"insert smaller number to the left"	t &gt; x ifTrue: [t left: (self insert: x at: t left)].	"insert bigger number to the right"	t &lt; x ifTrue: [t right: (self insert: x at: t right)]	"if t equals x, do nothing"	</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePreOrder:">printTreePreOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePreOrder: aNode left.			middle := aNode value printString.			right := self printTreePreOrder: aNode right.			space := String with: Character space.			^middle, space, left, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="remove:at:">remove: aNumber at: aNode 	"remove a number at the tree node"	"if tree is empty, nothing to remove"	aNode isNil ifTrue: [^nil].	"remove smaller number from the left tree"	aNode value &gt; aNumber ifTrue: [		aNode left: (self remove: aNumber at: aNode left ).		^aNode ].	"remove bigger number from the right tree"	aNode value &lt; aNumber ifTrue: [		aNode right: (self remove: aNumber at: aNode right ).		^aNode ].	"the current node contains the number; 	four cases: 0 child, 1 left child, 1 right child, 2 children"	"we are sure we will delete a node, therefor, update the remove status"	self removeStatus isNil		ifTrue: [ self removeStatus: aNumber printString ]		ifFalse: [ self removeStatus: removeStatus, '  ', aNumber printString ].	"when the current node have 2 children"	( aNode left isNil not ) &amp; ( aNode right isNil not ) ifTrue: [		aNode value: ( self findMin: aNode right ) value.		aNode right: ( self remove: aNode value at: aNode right ).		^aNode ].	"when the current node has left child but not right child"	aNode left isNil ifFalse: [ ^aNode left ].	"when the current node has right child but not left child"	aNode right isNil ifFalse: [ ^aNode right ].	"when the current node is a leaf node"	^nil.</body></methods><methods><class-id>MyTree.Node class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new:">new: aNumber	"Answer a newly created and initialized instance."	^super new initialize: aNumber</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&lt;">&lt; x 	^value &lt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="=">= x 	^value = x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&gt;">&gt; x 	^value &gt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize:">initialize: aNumber	"Initialize a newly created instance. This method must answer the receiver."	value := aNumber.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value:">value: x	value := x</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height:">height: x^height := x.</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left:">left: t	left := t</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right">right	^right</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value">value	^value</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	value &gt; aNumber 		ifTrue: 			[left isNil 				ifTrue: [^left := Node new: aNumber]				ifFalse: [^left add: aNumber]].	value &lt; aNumber 		ifTrue: 			[right isNil 				ifTrue: [^right := Node new: aNumber]				ifFalse: [^right add: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height">height	^height</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	value &gt; aNumber 		ifTrue: [left isNil ifTrue: [^nil] ifFalse: [^left remove: aNumber]].	value &lt; aNumber 		ifTrue: [right isNil ifTrue: [^nil] ifFalse: [^right remove: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left">left	^left</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right:">right: t	right := t</body></methods><methods><class-id>MyTree.BTreeEditor class</class-id> <category>interface specs</category><body package="BinaryTree" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Binary Search Tree Editor' 			#bounds: #(#{Graphics.Rectangle} 1684 303 2255 518 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 21 19 ) 					#name: #inputLabel 					#label: 'Input' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 100 ) 					#name: #outputLabel 					#label: 'Output' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 59 20 545 45 ) 					#name: #InputField 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 61 100 547 125 ) 					#name: #outputField 					#model: #output 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 61 57 179 88 ) 					#name: #addNodeButton 					#model: #addNode 					#label: 'Add Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 58 302 89 ) 					#name: #deleteButton 					#model: #deleteNode 					#label: 'Delete Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 59 139 177 170 ) 					#name: #addAllButton 					#model: #addAllNodes 					#label: 'Add All Nodes' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 182 139 300 170 ) 					#name: #printTreeInOrderButton 					#model: #printTreeInOrder 					#label: 'Print tree in-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 306 139 424 170 ) 					#name: #printTreePreOderButton 					#model: #printTreePreOrder 					#label: 'Print tree pre-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 429 139 547 170 ) 					#name: #printTreePostOrderButton 					#model: #printTreePostOrder 					#label: 'Print tree post-order' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="output">output	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^output isNil		ifTrue:			[output := String new asValue]		ifFalse:			[output]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="input">input	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^input isNil		ifTrue:			[input := String new asValue]		ifFalse:			[input]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	myTree := BTree new</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	"This stub method was generated by UIDefiner"	output value: 'Tree pre-order: ', myTree printTreePreOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	"This stub method was generated by UIDefiner"	output value: 'Tree post-order: ', myTree printTreePostOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	"This stub method was generated by UIDefiner"	output value: 'Tree in-order: ', myTree printTreeInOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="deleteNode">deleteNode	"delete one or more numbers from the tree"	| inputStream token |	myTree removeStatus: nil.	inputStream := input value readStream.	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree remove: token asNumber.	].	input value: ''.	myTree removeStatus isNil		ifTrue: [ output value: 'deleted nodes: (none)' ]		ifFalse: [ output value: 'deleted nodes: ', myTree removeStatus ].</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	"Add the values of all tree nodes"	output value: 'All Nodes totally: ' , myTree addAllNodes printString</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addNode">addNode	"add one or more numbers to a tree"	| inputStream token |	"clean up the tree's add node status"	myTree addStatus: nil.	"get the inputField and set it as a readonly stream"	inputStream := input value readStream.	"while reading stream is not finished, get a token as a number;	and add it to the binary search tree"	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree add: token asNumber.	].	"set inputField empty"	input value: ''.	"output status of the add node operation"	myTree addStatus isNil		ifTrue: [ output value: 'added nodes: (none)' ]		ifFalse: [ output value: 'added nodes: ', myTree addStatus ]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="applyBlockText">applyBlockText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^applyBlockText isNil		ifTrue:			[applyBlockText := String new asValue]		ifFalse:			[applyBlockText]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText  getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getValueFromKey">getValueFromKey	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getValueFromKey isNil		ifTrue:			[getValueFromKey := String new asValue]		ifFalse:			[getValueFromKey]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey  valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="valueInput">valueInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueInput isNil		ifTrue:			[valueInput := String new asValue]		ifFalse:			[valueInput]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput  keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="keyInput">keyInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyInput isNil		ifTrue:			[keyInput := String new asValue]		ifFalse:			[keyInput]</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token key value |		key := keyInput value readStream.			^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		^_value.</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		position == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		key == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 685 236 1309 684 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 341 0 78 0 576 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 343 0 110 0 575 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value token|		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].	_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.	"	[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	]."		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><do-it>| a |a := SortedDictionary new.a at: 'abc' put: '4'.a at: 'sad'.</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput  getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getAllKeys">getAllKeys	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getAllKeys isNil		ifTrue:			[getAllKeys := SelectionInList new]		ifFalse:			[getAllKeys]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllPairsList">AllPairsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllPairsList isNil		ifTrue:			[AllPairsList := SelectionInList new]		ifFalse:			[AllPairsList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList  AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllKeysList">AllKeysList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllKeysList isNil		ifTrue:			[AllKeysList := SelectionInList new]		ifFalse:			[AllKeysList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllValuesList">AllValuesList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllValuesList isNil		ifTrue:			[AllValuesList := SelectionInList new]		ifFalse:			[AllValuesList]</body></methods><remove-selector><class-id>DictionaryApp</class-id> <selector>getAllKeys</selector></remove-selector><do-it>DictionaryApp removeSelector: #getAllKeys</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		^list</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.		keyInput value: ''.	valueInput value: ''.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		getValueFromKey value: ''.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList = list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList := list.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 571 247 1195 695 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 25 0 294 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 405 0 27 0 578 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 298 0 78 0 435 0 97 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 110 0 434 0 131 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 703 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 258 0 80 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 678 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 456 0 78 0 691 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 110 0 691 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 266 0 230 0 467 0 419 0 ) 					#name: #List1 					#model: #AllKeysList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 56 0 191 0 212 0 212 0 ) 					#name: #ActionButton6 					#model: #getAllPairs 					#label: 'All Pairs' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 528 0 192 0 676 0 214 0 ) 					#name: #ActionButton8 					#model: #getAllValues 					#label: 'All Values' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 503 0 229 0 697 0 417 0 ) 					#name: #List3 					#model: #AllValuesList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 229 0 225 0 416 0 ) 					#name: #List2 					#model: #AllPairsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 282 0 191 0 448 0 212 0 ) 					#name: #ActionButton7 					#model: #getAllKeys 					#label: 'All Keys' 					#defaultable: true ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: (list at: i)].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: i].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList list: list. </body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.				AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: finalList.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllValuesList list: list.</body></methods><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>CodeComponent	create: #package	named: 'CS474'</do-it><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := nil.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>removing</category><body package="CS474" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := 0.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="size1">size1	^size</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := nil.	items := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| index element  |	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	items sortBlock:[:a :b | a &gt; b].	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedCollection new.a add: 1.a add: 10.a add: 5.a add: 2.a</do-it><class><name>DictionaryClass</name><environment>Smalltalk</environment><super>SortedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryClass	superclass: #{Smalltalk.SortedDictionary}	indexedType: #none	private: false	instanceVariableNames: 'key value '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key">key	^key</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := nil.	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>DictionaryClass removeFromSystem</do-it><do-it>DictionaryClass removeFromSystem</do-it><methods><class-id>DictionaryPair</class-id> <category>initialize-release</category><body package="CS474" selector="initialize:value:">initialize: new_key value:new_value	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := new_key.	value := new_value.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>| a |a:= (DictionaryPair new) key:5 value:10.a</do-it><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection sortBlock:[:a :b | a key &lt; b key].	 	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: _value.			self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.			self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair ) key: _key value:_value.		items add: pair.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.		^self</body></methods><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size = size + 1.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start end current|		start := 1. 	end:= size.	current:= 0.					^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start end current dummy|		start := 1. 	end:= size.	current:= 0.		[start &lt; end] whileTrue: [		dummy := start + (end-1)/2.						].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		[(items at: current) key = position] ifTrue: [			] 				].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end = current - 1].												].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size := size + 1.		^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].												].			^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].												].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := start + (end-1)/2.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + (end-1)/2) floor.		((items at: current) key = position) ifTrue: [^(items at: current)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a at: 'crap'.</do-it><do-it>| a |a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a at: 'abc' put: '123'.a at: 'abc'.</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: _key put: _value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| pair |	_key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].	_value == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: _value].		"((self at: _key) = "		pair:= (DictionaryPair new) key: _key value:_value.		items add: pair.	size := size + 1.		^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:value:">add: _key value: _value	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self at: newObject key put: newObject value</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self at: (newObject key) put: (newObject value)</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.</do-it><do-it>SortedDictionary organization addCategory: #enumerating</do-it><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self basicAt: index)]</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.				^self		</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size by: 1		do: [ :index | set add: (index value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index value) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) key) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) values) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a values</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		(items firstIndex) to: (items lastIndex)		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: ((items at: index) value) ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a values</do-it><do-it>NewDictionary organization addCategory: #allPairs</do-it><do-it>NewDictionary organization removeCategory: #allPairs</do-it><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: self size		do: [ :index | set add: (((self items) at: index))].			^set</body></methods><methods><class-id>NewDictionary</class-id> <category>accessing</category><body package="CS474" selector="allPairs">allPairs	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: self size		do: [ :index | set add: (index)].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self basicAt: (items at: index))]</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: index ].			^set</body></methods><do-it>| a pair |pair:= (DictionaryPair new) key: 'abc' value:'123'.a:= SortedDictionary new.a at: 'politicians' put: 'liars'.a at: 'crap' put: 'shit'.a add: pair.a at: 'abc'.a keys</do-it><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: index key ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	| set |		set:= OrderedCollection new.		1 to: size		do: [ :index | set add: (index key) ].			^set</body></methods><methods><class-id>SortedDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "		1 to: size do:		[:index | aBlock value: (self items at: index)]</body></methods><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:59 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:59 PM on February 17, 2018."</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 634 187 1252 711 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="applyBlock">applyBlock	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].		dictionary := SortedDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"		dictionary ifNotNil: [self resetDictionary].		dictionary := TreeDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	dictionary ifNotNil: [dictionary := nil].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		^self</body></methods><component-created><name>BinaryTree</name> <type>package</type></component-created><do-it>CodeComponent	create: #package	named: 'BinaryTree'</do-it><name-space><name>MyTree</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></name-space><do-it>Smalltalk defineNameSpace: #MyTree	private: false	imports: '			private Smalltalk.*			'	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><name-space-id>MyTree</name-space-id><body>name:         Wenling Chenproject:        CS 474 project 1CS account: wchenfile name:     chen.stDate:           10/7/2007Wchen is the namespace for this project</body></comment><class><name>Node</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #Node	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'value left right height '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.Node</class-id><body>Node class represent nodes in an binary search tree</body></comment><class><name>BTreeEditor</name><environment>MyTree</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output input myTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTreeEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'output input myTree '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTreeEditor</class-id><body>This the user interface for the project.Instance Variables:	input	&lt;ValueModel&gt;	accept a list of numbers for adding to the tree or deleting from the tree	myTree	&lt;BTree&gt;	a binary search tree	output	&lt;ValueModel&gt;	show the result of each operations: 		add node, delete node, add all nodes' total, print in-order, print pre-order, and print post-order</body></comment><class><name>BTree</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root addStatus removeStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTree	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root addStatus removeStatus '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTree</class-id><body>The BTree represent a binary search tree for the projectInstance Variables:	root	&lt;Object&gt;	the root node of the tree	addStatus 		the status of add node operation	removeStatus    the status of delete node operation</body></comment><methods><class-id>MyTree.BTree class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>MyTree.BTree class</class-id> <category>testing</category><body package="BinaryTree" selector="addNode">addNode	| t |	t := BTree new.	t add: 30.	t add: 50.	t add: 70.	t add: 90.	t add: 20.	t add: 60.	Transcript show: t printTreeInOrder.	Transcript show: t printTreePreOrder.	Transcript show: t printTreePostOrder.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root">root	^root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="insert:">insert: x	root := self insert: x at: root </body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus:">removeStatus: aString	removeStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus:">addStatus: aString	addStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	^self addAllNodes: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMax">finMax	^self valueAt: (self findMax: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus">removeStatus	^removeStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMin">finMin	^self findMin: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	"remove a node"	root := self remove: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="makeEmpty">makeEmpty	root := nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	^self printTreePreOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	^self printTreeInOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus">addStatus	^addStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	^self printTreePostOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="isEmpty">isEmpty	^root isNil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	root := self add: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="find:">find: x 	^self valueAt: (self find: x at: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMin:">findMin: aNode	aNode isNil ifTrue: [^nil].	aNode left isNil ifTrue: [ ^aNode ].	^ self findMin: aNode left.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMax:">findMax: t 	| tmp |	tmp := t.	tmp isNil ifTrue: [^nil].	[tmp right isNil] whileFalse: [tmp := tmp right].	^tmp</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="addAllNodes:">addAllNodes: aNode 	| left middle right |	aNode isNil ifTrue: [ ^0 ].	left := self addAllNodes: aNode left.	middle := aNode value.	right := self addAllNodes: aNode right.	^(left + middle + right)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="add:at:">add: aNumber at: aNode 	"add a number at the tree node"	aNode isNil ifTrue: [			|newNode|			newNode := Node new: aNumber.			addStatus isNil 				ifTrue: [ addStatus := newNode value printString ]				ifFalse: [ addStatus := addStatus, ' ', newNode value printString ].			^newNode ]		ifFalse: [			aNode value &gt; aNumber 				ifTrue: 					["add smaller number to the left tree"					aNode left: (self add: aNumber at: aNode left ).					^aNode ].			aNode value &lt; aNumber 				ifTrue: 					["add bigger number to the right tree"					aNode right: (self add: aNumber at: aNode right ) .					^aNode ].			^aNode ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreeInOrder:">printTreeInOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreeInOrder: aNode left.			middle := aNode value printString.			right := self printTreeInOrder: aNode right.			space := String with: Character space.			^left, space, middle, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="find:at:">find: x at: t 	| tmp |	tmp := t.	[tmp isNil not] whileTrue: 			[tmp &gt; x ifTrue: [tmp := tmp left].			tmp &lt; x ifTrue: [tmp := tmp right].			tmp = x ifTrue: [^tmp]].	^nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePostOrder:">printTreePostOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePostOrder: aNode left.			middle := aNode value printString.			right := self printTreePostOrder: aNode right.			space := String with: Character space.			^left, space, right, space, middle  ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="valueAt:">valueAt: t 	t isNil ifTrue: [^nil] ifFalse: [^t value]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="insert:at:">insert: x at: t |tmp|	"insert number x at node t"	t isNil ifTrue: [ tmp := Node new: x].	"insert smaller number to the left"	t &gt; x ifTrue: [t left: (self insert: x at: t left)].	"insert bigger number to the right"	t &lt; x ifTrue: [t right: (self insert: x at: t right)]	"if t equals x, do nothing"	</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePreOrder:">printTreePreOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePreOrder: aNode left.			middle := aNode value printString.			right := self printTreePreOrder: aNode right.			space := String with: Character space.			^middle, space, left, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="remove:at:">remove: aNumber at: aNode 	"remove a number at the tree node"	"if tree is empty, nothing to remove"	aNode isNil ifTrue: [^nil].	"remove smaller number from the left tree"	aNode value &gt; aNumber ifTrue: [		aNode left: (self remove: aNumber at: aNode left ).		^aNode ].	"remove bigger number from the right tree"	aNode value &lt; aNumber ifTrue: [		aNode right: (self remove: aNumber at: aNode right ).		^aNode ].	"the current node contains the number; 	four cases: 0 child, 1 left child, 1 right child, 2 children"	"we are sure we will delete a node, therefor, update the remove status"	self removeStatus isNil		ifTrue: [ self removeStatus: aNumber printString ]		ifFalse: [ self removeStatus: removeStatus, '  ', aNumber printString ].	"when the current node have 2 children"	( aNode left isNil not ) &amp; ( aNode right isNil not ) ifTrue: [		aNode value: ( self findMin: aNode right ) value.		aNode right: ( self remove: aNode value at: aNode right ).		^aNode ].	"when the current node has left child but not right child"	aNode left isNil ifFalse: [ ^aNode left ].	"when the current node has right child but not left child"	aNode right isNil ifFalse: [ ^aNode right ].	"when the current node is a leaf node"	^nil.</body></methods><methods><class-id>MyTree.Node class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new:">new: aNumber	"Answer a newly created and initialized instance."	^super new initialize: aNumber</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&lt;">&lt; x 	^value &lt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="=">= x 	^value = x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&gt;">&gt; x 	^value &gt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize:">initialize: aNumber	"Initialize a newly created instance. This method must answer the receiver."	value := aNumber.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value:">value: x	value := x</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height:">height: x^height := x.</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left:">left: t	left := t</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right">right	^right</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value">value	^value</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	value &gt; aNumber 		ifTrue: 			[left isNil 				ifTrue: [^left := Node new: aNumber]				ifFalse: [^left add: aNumber]].	value &lt; aNumber 		ifTrue: 			[right isNil 				ifTrue: [^right := Node new: aNumber]				ifFalse: [^right add: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height">height	^height</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	value &gt; aNumber 		ifTrue: [left isNil ifTrue: [^nil] ifFalse: [^left remove: aNumber]].	value &lt; aNumber 		ifTrue: [right isNil ifTrue: [^nil] ifFalse: [^right remove: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left">left	^left</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right:">right: t	right := t</body></methods><methods><class-id>MyTree.BTreeEditor class</class-id> <category>interface specs</category><body package="BinaryTree" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Binary Search Tree Editor' 			#bounds: #(#{Graphics.Rectangle} 1684 303 2255 518 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 21 19 ) 					#name: #inputLabel 					#label: 'Input' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 100 ) 					#name: #outputLabel 					#label: 'Output' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 59 20 545 45 ) 					#name: #InputField 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 61 100 547 125 ) 					#name: #outputField 					#model: #output 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 61 57 179 88 ) 					#name: #addNodeButton 					#model: #addNode 					#label: 'Add Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 58 302 89 ) 					#name: #deleteButton 					#model: #deleteNode 					#label: 'Delete Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 59 139 177 170 ) 					#name: #addAllButton 					#model: #addAllNodes 					#label: 'Add All Nodes' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 182 139 300 170 ) 					#name: #printTreeInOrderButton 					#model: #printTreeInOrder 					#label: 'Print tree in-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 306 139 424 170 ) 					#name: #printTreePreOderButton 					#model: #printTreePreOrder 					#label: 'Print tree pre-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 429 139 547 170 ) 					#name: #printTreePostOrderButton 					#model: #printTreePostOrder 					#label: 'Print tree post-order' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="output">output	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^output isNil		ifTrue:			[output := String new asValue]		ifFalse:			[output]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="input">input	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^input isNil		ifTrue:			[input := String new asValue]		ifFalse:			[input]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	myTree := BTree new</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	"This stub method was generated by UIDefiner"	output value: 'Tree pre-order: ', myTree printTreePreOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	"This stub method was generated by UIDefiner"	output value: 'Tree post-order: ', myTree printTreePostOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	"This stub method was generated by UIDefiner"	output value: 'Tree in-order: ', myTree printTreeInOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="deleteNode">deleteNode	"delete one or more numbers from the tree"	| inputStream token |	myTree removeStatus: nil.	inputStream := input value readStream.	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree remove: token asNumber.	].	input value: ''.	myTree removeStatus isNil		ifTrue: [ output value: 'deleted nodes: (none)' ]		ifFalse: [ output value: 'deleted nodes: ', myTree removeStatus ].</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	"Add the values of all tree nodes"	output value: 'All Nodes totally: ' , myTree addAllNodes printString</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addNode">addNode	"add one or more numbers to a tree"	| inputStream token |	"clean up the tree's add node status"	myTree addStatus: nil.	"get the inputField and set it as a readonly stream"	inputStream := input value readStream.	"while reading stream is not finished, get a token as a number;	and add it to the binary search tree"	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree add: token asNumber.	].	"set inputField empty"	input value: ''.	"output status of the add node operation"	myTree addStatus isNil		ifTrue: [ output value: 'added nodes: (none)' ]		ifFalse: [ output value: 'added nodes: ', myTree addStatus ]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="applyBlockText">applyBlockText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^applyBlockText isNil		ifTrue:			[applyBlockText := String new asValue]		ifFalse:			[applyBlockText]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText  getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getValueFromKey">getValueFromKey	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getValueFromKey isNil		ifTrue:			[getValueFromKey := String new asValue]		ifFalse:			[getValueFromKey]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey  valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="valueInput">valueInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueInput isNil		ifTrue:			[valueInput := String new asValue]		ifFalse:			[valueInput]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput  keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="keyInput">keyInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyInput isNil		ifTrue:			[keyInput := String new asValue]		ifFalse:			[keyInput]</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token key value |		key := keyInput value readStream.			^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		^_value.</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		position == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		key == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 685 236 1309 684 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 341 0 78 0 576 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 343 0 110 0 575 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value token|		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].	_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.	"	[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	]."		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><do-it>| a |a := SortedDictionary new.a at: 'abc' put: '4'.a at: 'sad'.</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput  getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getAllKeys">getAllKeys	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getAllKeys isNil		ifTrue:			[getAllKeys := SelectionInList new]		ifFalse:			[getAllKeys]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllPairsList">AllPairsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllPairsList isNil		ifTrue:			[AllPairsList := SelectionInList new]		ifFalse:			[AllPairsList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList  AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllKeysList">AllKeysList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllKeysList isNil		ifTrue:			[AllKeysList := SelectionInList new]		ifFalse:			[AllKeysList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllValuesList">AllValuesList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllValuesList isNil		ifTrue:			[AllValuesList := SelectionInList new]		ifFalse:			[AllValuesList]</body></methods><remove-selector><class-id>DictionaryApp</class-id> <selector>getAllKeys</selector></remove-selector><do-it>DictionaryApp removeSelector: #getAllKeys</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		^list</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.		keyInput value: ''.	valueInput value: ''.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		getValueFromKey value: ''.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList = list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList := list.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 571 247 1195 695 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 25 0 294 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 405 0 27 0 578 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 298 0 78 0 435 0 97 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 110 0 434 0 131 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 703 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 258 0 80 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 678 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 456 0 78 0 691 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 110 0 691 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 266 0 230 0 467 0 419 0 ) 					#name: #List1 					#model: #AllKeysList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 56 0 191 0 212 0 212 0 ) 					#name: #ActionButton6 					#model: #getAllPairs 					#label: 'All Pairs' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 528 0 192 0 676 0 214 0 ) 					#name: #ActionButton8 					#model: #getAllValues 					#label: 'All Values' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 503 0 229 0 697 0 417 0 ) 					#name: #List3 					#model: #AllValuesList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 229 0 225 0 416 0 ) 					#name: #List2 					#model: #AllPairsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 282 0 191 0 448 0 212 0 ) 					#name: #ActionButton7 					#model: #getAllKeys 					#label: 'All Keys' 					#defaultable: true ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: (list at: i)].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: i].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList list: list. </body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.				AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: finalList.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllValuesList list: list.</body></methods><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 17, 2018' '2:46:59 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 2:46:59 PM on February 17, 2018."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>getValueFromKey</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>getValueFromKey</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllKeysList</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllKeysList</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllValuesList</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllValuesList</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>applyBlockText</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>applyBlockText</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>keyInput</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>keyInput</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllPairsList</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>AllPairsList</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>valueInput</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>valueInput</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 634 187 1252 711 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="applyBlock">applyBlock	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newSD">newSD	dictionary ifNotNil: [self resetDictionary].		dictionary := SortedDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="newTD">newTD	"This stub method was generated by UIDefiner"		dictionary ifNotNil: [self resetDictionary].		dictionary := TreeDictionary new.	^dictionary</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="resetDictionary">resetDictionary	"This stub method was generated by UIDefiner"	dictionary ifNotNil: [dictionary := nil].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		^self</body></methods><do-it>CodeComponent	create: #package	named: 'BinaryTree'</do-it><do-it>CodeComponent	create: #package	named: 'BinaryTree'</do-it><name-space><name>MyTree</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></name-space><do-it>Smalltalk defineNameSpace: #MyTree	private: false	imports: '			private Smalltalk.*			'	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><name-space><name>MyTree</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></name-space><do-it>Smalltalk defineNameSpace: #MyTree	private: false	imports: '			private Smalltalk.*			'	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><name-space-id>MyTree</name-space-id><body>name:         Wenling Chenproject:        CS 474 project 1CS account: wchenfile name:     chen.stDate:           10/7/2007Wchen is the namespace for this project</body></comment><class><name>Node</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #Node	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'value left right height '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><class><name>Node</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #Node	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'value left right height '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.Node</class-id><body>Node class represent nodes in an binary search tree</body></comment><class><name>BTreeEditor</name><environment>MyTree</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output input myTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTreeEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'output input myTree '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><class><name>BTreeEditor</name><environment>MyTree</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output input myTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTreeEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'output input myTree '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTreeEditor</class-id><body>This the user interface for the project.Instance Variables:	input	&lt;ValueModel&gt;	accept a list of numbers for adding to the tree or deleting from the tree	myTree	&lt;BTree&gt;	a binary search tree	output	&lt;ValueModel&gt;	show the result of each operations: 		add node, delete node, add all nodes' total, print in-order, print pre-order, and print post-order</body></comment><class><name>BTree</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root addStatus removeStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTree	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root addStatus removeStatus '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><class><name>BTree</name><environment>MyTree</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root addStatus removeStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>BinaryTree</category><attributes><package>BinaryTree</package></attributes></class><do-it>Smalltalk.MyTree defineClass: #BTree	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root addStatus removeStatus '	classInstanceVariableNames: ''	imports: ''	category: 'BinaryTree'	attributes: #(			#(#package 'BinaryTree'))</do-it><comment><class-id>MyTree.BTree</class-id><body>The BTree represent a binary search tree for the projectInstance Variables:	root	&lt;Object&gt;	the root node of the tree	addStatus 		the status of add node operation	removeStatus    the status of delete node operation</body></comment><methods><class-id>MyTree.BTree class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>MyTree.BTree class</class-id> <category>testing</category><body package="BinaryTree" selector="addNode">addNode	| t |	t := BTree new.	t add: 30.	t add: 50.	t add: 70.	t add: 90.	t add: 20.	t add: 60.	Transcript show: t printTreeInOrder.	Transcript show: t printTreePreOrder.	Transcript show: t printTreePostOrder.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	root := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root">root	^root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="insert:">insert: x	root := self insert: x at: root </body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus:">removeStatus: aString	removeStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus:">addStatus: aString	addStatus := aString</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	^self addAllNodes: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMax">finMax	^self valueAt: (self findMax: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="removeStatus">removeStatus	^removeStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="finMin">finMin	^self findMin: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	"remove a node"	root := self remove: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="makeEmpty">makeEmpty	root := nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	^self printTreePreOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	^self printTreeInOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="addStatus">addStatus	^addStatus</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	^self printTreePostOrder: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="isEmpty">isEmpty	^root isNil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	root := self add: aNumber at: root</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="find:">find: x 	^self valueAt: (self find: x at: root)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>accessing</category><body package="BinaryTree" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMin:">findMin: aNode	aNode isNil ifTrue: [^nil].	aNode left isNil ifTrue: [ ^aNode ].	^ self findMin: aNode left.</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="findMax:">findMax: t 	| tmp |	tmp := t.	tmp isNil ifTrue: [^nil].	[tmp right isNil] whileFalse: [tmp := tmp right].	^tmp</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="addAllNodes:">addAllNodes: aNode 	| left middle right |	aNode isNil ifTrue: [ ^0 ].	left := self addAllNodes: aNode left.	middle := aNode value.	right := self addAllNodes: aNode right.	^(left + middle + right)</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="add:at:">add: aNumber at: aNode 	"add a number at the tree node"	aNode isNil ifTrue: [			|newNode|			newNode := Node new: aNumber.			addStatus isNil 				ifTrue: [ addStatus := newNode value printString ]				ifFalse: [ addStatus := addStatus, ' ', newNode value printString ].			^newNode ]		ifFalse: [			aNode value &gt; aNumber 				ifTrue: 					["add smaller number to the left tree"					aNode left: (self add: aNumber at: aNode left ).					^aNode ].			aNode value &lt; aNumber 				ifTrue: 					["add bigger number to the right tree"					aNode right: (self add: aNumber at: aNode right ) .					^aNode ].			^aNode ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreeInOrder:">printTreeInOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreeInOrder: aNode left.			middle := aNode value printString.			right := self printTreeInOrder: aNode right.			space := String with: Character space.			^left, space, middle, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="find:at:">find: x at: t 	| tmp |	tmp := t.	[tmp isNil not] whileTrue: 			[tmp &gt; x ifTrue: [tmp := tmp left].			tmp &lt; x ifTrue: [tmp := tmp right].			tmp = x ifTrue: [^tmp]].	^nil</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePostOrder:">printTreePostOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePostOrder: aNode left.			middle := aNode value printString.			right := self printTreePostOrder: aNode right.			space := String with: Character space.			^left, space, right, space, middle  ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="valueAt:">valueAt: t 	t isNil ifTrue: [^nil] ifFalse: [^t value]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="insert:at:">insert: x at: t |tmp|	"insert number x at node t"	t isNil ifTrue: [ tmp := Node new: x].	"insert smaller number to the left"	t &gt; x ifTrue: [t left: (self insert: x at: t left)].	"insert bigger number to the right"	t &lt; x ifTrue: [t right: (self insert: x at: t right)]	"if t equals x, do nothing"	</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="printTreePreOrder:">printTreePreOrder: aNode 	| left middle right space |	aNode isNil 		ifTrue: [^'']		ifFalse: 			[left := self printTreePreOrder: aNode left.			middle := aNode value printString.			right := self printTreePreOrder: aNode right.			space := String with: Character space.			^middle, space, left, space, right ]</body></methods><methods><class-id>MyTree.BTree</class-id> <category>private</category><body package="BinaryTree" selector="remove:at:">remove: aNumber at: aNode 	"remove a number at the tree node"	"if tree is empty, nothing to remove"	aNode isNil ifTrue: [^nil].	"remove smaller number from the left tree"	aNode value &gt; aNumber ifTrue: [		aNode left: (self remove: aNumber at: aNode left ).		^aNode ].	"remove bigger number from the right tree"	aNode value &lt; aNumber ifTrue: [		aNode right: (self remove: aNumber at: aNode right ).		^aNode ].	"the current node contains the number; 	four cases: 0 child, 1 left child, 1 right child, 2 children"	"we are sure we will delete a node, therefor, update the remove status"	self removeStatus isNil		ifTrue: [ self removeStatus: aNumber printString ]		ifFalse: [ self removeStatus: removeStatus, '  ', aNumber printString ].	"when the current node have 2 children"	( aNode left isNil not ) &amp; ( aNode right isNil not ) ifTrue: [		aNode value: ( self findMin: aNode right ) value.		aNode right: ( self remove: aNode value at: aNode right ).		^aNode ].	"when the current node has left child but not right child"	aNode left isNil ifFalse: [ ^aNode left ].	"when the current node has right child but not left child"	aNode right isNil ifFalse: [ ^aNode right ].	"when the current node is a leaf node"	^nil.</body></methods><methods><class-id>MyTree.Node class</class-id> <category>instance creation</category><body package="BinaryTree" selector="new:">new: aNumber	"Answer a newly created and initialized instance."	^super new initialize: aNumber</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&lt;">&lt; x 	^value &lt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="=">= x 	^value = x</body></methods><methods><class-id>MyTree.Node</class-id> <category>comparing</category><body package="BinaryTree" selector="&gt;">&gt; x 	^value &gt; x</body></methods><methods><class-id>MyTree.Node</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize:">initialize: aNumber	"Initialize a newly created instance. This method must answer the receiver."	value := aNumber.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value:">value: x	value := x</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height:">height: x^height := x.</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left:">left: t	left := t</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right">right	^right</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="value">value	^value</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="add:">add: aNumber 	value &gt; aNumber 		ifTrue: 			[left isNil 				ifTrue: [^left := Node new: aNumber]				ifFalse: [^left add: aNumber]].	value &lt; aNumber 		ifTrue: 			[right isNil 				ifTrue: [^right := Node new: aNumber]				ifFalse: [^right add: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="height">height	^height</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="remove:">remove: aNumber 	value &gt; aNumber 		ifTrue: [left isNil ifTrue: [^nil] ifFalse: [^left remove: aNumber]].	value &lt; aNumber 		ifTrue: [right isNil ifTrue: [^nil] ifFalse: [^right remove: aNumber]].	^nil</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="left">left	^left</body></methods><methods><class-id>MyTree.Node</class-id> <category>accessing</category><body package="BinaryTree" selector="right:">right: t	right := t</body></methods><methods><class-id>MyTree.BTreeEditor class</class-id> <category>interface specs</category><body package="BinaryTree" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Binary Search Tree Editor' 			#bounds: #(#{Graphics.Rectangle} 1684 303 2255 518 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 21 19 ) 					#name: #inputLabel 					#label: 'Input' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 100 ) 					#name: #outputLabel 					#label: 'Output' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 59 20 545 45 ) 					#name: #InputField 					#model: #input ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 61 100 547 125 ) 					#name: #outputField 					#model: #output 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 61 57 179 88 ) 					#name: #addNodeButton 					#model: #addNode 					#label: 'Add Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 58 302 89 ) 					#name: #deleteButton 					#model: #deleteNode 					#label: 'Delete Node' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 59 139 177 170 ) 					#name: #addAllButton 					#model: #addAllNodes 					#label: 'Add All Nodes' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 182 139 300 170 ) 					#name: #printTreeInOrderButton 					#model: #printTreeInOrder 					#label: 'Print tree in-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 306 139 424 170 ) 					#name: #printTreePreOderButton 					#model: #printTreePreOrder 					#label: 'Print tree pre-order' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 429 139 547 170 ) 					#name: #printTreePostOrderButton 					#model: #printTreePostOrder 					#label: 'Print tree post-order' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="output">output	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^output isNil		ifTrue:			[output := String new asValue]		ifFalse:			[output]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>aspects</category><body package="BinaryTree" selector="input">input	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^input isNil		ifTrue:			[input := String new asValue]		ifFalse:			[input]</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>initialize-release</category><body package="BinaryTree" selector="initialize">initialize	myTree := BTree new</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePreOrder">printTreePreOrder	"This stub method was generated by UIDefiner"	output value: 'Tree pre-order: ', myTree printTreePreOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreePostOrder">printTreePostOrder	"This stub method was generated by UIDefiner"	output value: 'Tree post-order: ', myTree printTreePostOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="printTreeInOrder">printTreeInOrder	"This stub method was generated by UIDefiner"	output value: 'Tree in-order: ', myTree printTreeInOrder.</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="deleteNode">deleteNode	"delete one or more numbers from the tree"	| inputStream token |	myTree removeStatus: nil.	inputStream := input value readStream.	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree remove: token asNumber.	].	input value: ''.	myTree removeStatus isNil		ifTrue: [ output value: 'deleted nodes: (none)' ]		ifFalse: [ output value: 'deleted nodes: ', myTree removeStatus ].</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addAllNodes">addAllNodes	"Add the values of all tree nodes"	output value: 'All Nodes totally: ' , myTree addAllNodes printString</body></methods><methods><class-id>MyTree.BTreeEditor</class-id> <category>actions</category><body package="BinaryTree" selector="addNode">addNode	"add one or more numbers to a tree"	| inputStream token |	"clean up the tree's add node status"	myTree addStatus: nil.	"get the inputField and set it as a readonly stream"	inputStream := input value readStream.	"while reading stream is not finished, get a token as a number;	and add it to the binary search tree"	[inputStream atEnd]	whileFalse: [		token := inputStream upTo: Character space.		myTree add: token asNumber.	].	"set inputField empty"	input value: ''.	"output status of the add node operation"	myTree addStatus isNil		ifTrue: [ output value: 'added nodes: (none)' ]		ifFalse: [ output value: 'added nodes: ', myTree addStatus ]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary  applyBlockText '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="applyBlockText">applyBlockText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^applyBlockText isNil		ifTrue:			[applyBlockText := String new asValue]		ifFalse:			[applyBlockText]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText  getValueFromKey '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getValueFromKey">getValueFromKey	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getValueFromKey isNil		ifTrue:			[getValueFromKey := String new asValue]		ifFalse:			[getValueFromKey]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey  valueInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="valueInput">valueInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueInput isNil		ifTrue:			[valueInput := String new asValue]		ifFalse:			[valueInput]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput  keyInput '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="keyInput">keyInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^keyInput isNil		ifTrue:			[keyInput := String new asValue]		ifFalse:			[keyInput]</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token key value |		key := keyInput value readStream.			^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| token _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.	_value := valueInput value readStream.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		^_value.</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: position	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		|  start current end|		position == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		(size = 0) ifTrue: [^nil].	start := 1. 	end:= size.		[start &lt;= end] whileTrue: [		current := (start + ((end-1)/2)) floor.		((items at: current) key = position) ifTrue: [^((items at: current) value)]. 		((items at: current) key &lt; position) ifTrue: [start:= current + 1] 									ifFalse: [end := current - 1].										].			^nil</body></methods><methods><class-id>TreeDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	|  searchObject |		key == nil ifTrue: [^self subscriptBoundsErrorFor: #at index: nil ].		searchObject:= tree getValueAt: key.		^searchObject.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value readStream.		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 685 236 1309 684 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 25 0 264 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 359 0 27 0 532 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 83 0 195 0 220 0 216 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 233 0 223 0 254 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 625 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 196 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 234 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 341 0 78 0 576 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 343 0 110 0 575 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value token|		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].	_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.	"	[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	]."		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value readStream.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.		[_key atEnd]	whileFalse: [		token := _key upTo: Character space.		_key := token asString.	].		_value := valueInput value readStream.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		[_value atEnd]	whileFalse: [		token := _value upTo: Character space.		_value := token asString.	].		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value token |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><do-it>| a |a := SortedDictionary new.a at: 'abc' put: '4'.a at: 'sad'.</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		_value := nil.		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput  getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="getAllKeys">getAllKeys	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getAllKeys isNil		ifTrue:			[getAllKeys := SelectionInList new]		ifFalse:			[getAllKeys]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys  AllPairsList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllPairsList">AllPairsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllPairsList isNil		ifTrue:			[AllPairsList := SelectionInList new]		ifFalse:			[AllPairsList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList  AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllKeysList">AllKeysList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllKeysList isNil		ifTrue:			[AllKeysList := SelectionInList new]		ifFalse:			[AllKeysList]</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	^self</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList  AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>aspects</category><body package="CS474" selector="AllValuesList">AllValuesList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AllValuesList isNil		ifTrue:			[AllValuesList := SelectionInList new]		ifFalse:			[AllValuesList]</body></methods><remove-selector><class-id>DictionaryApp</class-id> <selector>getAllKeys</selector></remove-selector><do-it>DictionaryApp removeSelector: #getAllKeys</do-it><do-it>DictionaryApp removeSelector: #getAllKeys</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput getAllKeys AllPairsList AllKeysList AllValuesList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|   |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	^self</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		^list</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="addPiar">addPiar	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := keyInput value.			_value := valueInput value.		dictionary at: _key put: _value.		keyInput value: ''.	valueInput value: ''.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getValue">getValue	"This stub method was generated by UIDefiner"		| _key _value |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].		_key := getValueFromKey value .		_value := dictionary at: _key.		getValueFromKey value: ''.		_value ifNil: [^Dialog warn: 'No Pair found'].		^Dialog warn: ( 'The value is ' , _value).</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList = list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList := list.</body></methods><methods><class-id>DictionaryApp class</class-id> <category>interface specs</category><body package="CS474" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Dictionary' 			#bounds: #(#{Graphics.Rectangle} 571 247 1195 695 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 3072 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5557 6360 7998 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 25 0 294 0 46 0 ) 					#name: #ActionButton1 					#model: #newSD 					#label: 'New Sorted Dictionary' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 405 0 27 0 578 0 48 0 ) 					#name: #ActionButton2 					#model: #newTD 					#label: 'New Tree Dictionary' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 79 0 218 0 98 0 ) 					#name: #InputField1 					#model: #keyInput ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 106 0 218 0 125 0 ) 					#name: #InputField2 					#model: #valueInput ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0 138 0 222 0 159 0 ) 					#name: #ActionButton3 					#model: #addPiar 					#label: 'Add new pair' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 80 0 ) 					#name: #Label1 					#label: 'Key:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 44 0 108 0 ) 					#name: #Label2 					#label: 'Value:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 298 0 78 0 435 0 97 0 ) 					#name: #InputField3 					#model: #getValueFromKey ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 256 0 110 0 434 0 131 0 ) 					#name: #ActionButton4 					#model: #getValue 					#label: 'Get Value' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0 64 0 703 0 68 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 258 0 80 0 ) 					#name: #Label3 					#label: 'Key:' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 35 0 175 0 678 0 179 0 ) 					#name: #Divider2 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 456 0 78 0 691 0 97 0 ) 					#name: #InputField4 					#model: #applyBlockText ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 110 0 691 0 131 0 ) 					#name: #ActionButton5 					#model: #applyBlock 					#label: 'Apply Block' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 266 0 230 0 467 0 419 0 ) 					#name: #List1 					#model: #AllKeysList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 56 0 191 0 212 0 212 0 ) 					#name: #ActionButton6 					#model: #getAllPairs 					#label: 'All Pairs' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 528 0 192 0 676 0 214 0 ) 					#name: #ActionButton8 					#model: #getAllValues 					#label: 'All Values' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 503 0 229 0 697 0 417 0 ) 					#name: #List3 					#model: #AllValuesList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 229 0 225 0 416 0 ) 					#name: #List2 					#model: #AllPairsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 282 0 191 0 448 0 212 0 ) 					#name: #ActionButton7 					#model: #getAllKeys 					#label: 'All Keys' 					#defaultable: true ) ) ) )</body></methods><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryApp	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'dictionary applyBlockText getValueFromKey valueInput keyInput AllPairsList AllKeysList AllValuesList '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: (list at: i)].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		list do: [:i | AllKeysList add: i].</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllKeys">getAllKeys	"This stub method was generated by UIDefiner"		|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary keys.		AllKeysList list: list. </body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.				AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: list.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllPairs">getAllPairs	"This stub method was generated by UIDefiner"	|  list  finalList string|		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary allPairs.		finalList := OrderedCollection new.	string := String new.		list do: [:i | string add: (i key , ' --&gt; ' , i value).				finalList add: string.].		AllKeysList list: finalList.</body></methods><methods><class-id>DictionaryApp</class-id> <category>actions</category><body package="CS474" selector="getAllValues">getAllValues	"This stub method was generated by UIDefiner"	|  list |		dictionary ifNil: [^Dialog warn: 'Create a new dictionary first'].	list := dictionary values.		AllValuesList list: list.</body></methods><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>| a |a:= Dictionary new.a at: 'politicians' put: 'liars'.a</do-it><do-it>CodeComponent	create: #package	named: 'CS474'</do-it><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := nil.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>NewDictionary</class-id> <category>adding</category><body package="CS474" selector="add:">add: newObject	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>enumerating</category><body package="CS474" selector="do:">do: aBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>removing</category><body package="CS474" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	" *** This method was defined by Collection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>NewDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	DictionaryInUse := 0.	dictionary := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="size1">size1	^size</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := nil.	items := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:">at: key	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="keys">keys	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="values">values	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>SortedDictionary</class-id> <category>accessing</category><body package="CS474" selector="at:put:">at: key put: value	" *** This method was defined by NewDictionary as a subclass responsibility.	Replace its body with a proper implementation. *** "		| index element  |	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>SortedDictionary</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	size := 0.	items := SortedCollection new.	items sortBlock:[:a :b | a &gt; b].	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedDictionary.a</do-it><do-it>| a |a:= SortedCollection new.a add: 1.a add: 10.a add: 5.a add: 2.a</do-it><class><name>DictionaryClass</name><environment>Smalltalk</environment><super>SortedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryClass	superclass: #{Smalltalk.SortedDictionary}	indexedType: #none	private: false	instanceVariableNames: 'key value '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><class><name>DictionaryClass</name><environment>Smalltalk</environment><super>SortedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>CS474</package></attributes></class><do-it>Smalltalk defineClass: #DictionaryClass	superclass: #{Smalltalk.SortedDictionary}	indexedType: #none	private: false	instanceVariableNames: 'key value '	classInstanceVariableNames: ''	imports: ''	category: ''	attributes: #(			#(#package 'CS474'))</do-it><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key">key	^key</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value">value	^value</body></methods><methods><class-id>DictionaryClass</class-id> <category>accessing</category><body package="CS474" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>DictionaryClass</class-id> <category>initialize-release</category><body package="CS474" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	key := nil.	value := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>DictionaryClass removeFromSystem</do-it><do-it>DictionaryClass removeFromSystem</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im' 'February 18, 2018' '9:25:16 PM')""An image file c:\Users\Srinivas\Documents\VisualWorks Projects\CS474Project1\CS474Project1.im was created at 9:25:16 PM on February 18, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Desktop\CS474Project1.im' 'February 18, 2018' '9:25:23 PM')""An image file c:\Users\Srinivas\Desktop\CS474Project1.im was created at 9:25:23 PM on February 18, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Google Drive\CS474Project1.im' 'February 18, 2018' '9:25:35 PM')""An image file c:\Users\Srinivas\Google Drive\CS474Project1.im was created at 9:25:35 PM on February 18, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Google Drive\CS474Project1.im' 'February 18, 2018' '9:41:37 PM')""An image file c:\Users\Srinivas\Google Drive\CS474Project1.im was created at 9:41:37 PM on February 18, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Srinivas\Google Drive\CS474Project1.im' 'February 18, 2018' '9:41:41 PM')""An image file c:\Users\Srinivas\Google Drive\CS474Project1.im was created at 9:41:41 PM on February 18, 2018."</do-it>